2021.08.22

* 모델링의 특징 

1. 현실세계를 일정한 형식에 맞추어 표현하는 추상화의 의미를 가질 수 있음
2. 복잡한 현실을 제한된 언어나 표기법을 통해 이해하기 쉽게 하는 단순화의 의미를 가지고 있음
3. 애매모호함을 배제하고 누구나 이해가 가능하도록 정확하게 현상을 기술하는 정확화의 의미를 가짐 


* 데이터모델링시 유의사항 
1. 중복성 - 데이터베이스가 여러장소에 같은 정보를 저장하지 않도로 한다. 
2. 비유연성 - 데이터의 정의를 데이터의 사용프로세스와 분리함으로써 수시로 데이터모델이 변경되는 것을 방지한다. 
3. 비일관성 - 데이터 모델링을 할 때 데이터와 데이터간의 상호 연관관계에 대해 명확하게 정의해야한다. 


* 데이터베이스 스키마 구조는 3단계로 구분되고, 
각각은 상호독립적인 의미를 가지고 고유한 기능을 가진다. 
개념스키마(Conceptual schema): 통합관점의 스키마구조를 표현한 것, 데이터 모델링은 통합 관점의 
뷰를 가지고 있는 개념 스키마를 만들어가는 과정으로 이해할 수 있음. 


* ERD 표기법 종류 - Baker 표기법, IE 표기법 
Baker 표기법은 점선, 실선 등으로 표기 
IE 표기법은 실선과 동그라미 등으로 표기 함. 

* ERD 
- 1976년에 피터첸에 의해 Entity-Relationship Model이라는 표기법이 만들어졌다. 
- Entity 도출 -> Entity 배치 -> 관계설정 -> 관계명 기술의 흐름으로 작업을 진행한다. 
- 관계의 명칭은 관계 표현에 있어서 매우 중요한 부분에 해당한다. 
- 가장 중요한 엔티티를 왼쪽 상단에 배치(사람의 눈은 왼쪽에서 오른쪽, 위쪽에서 아래쪽으로 이동하는 경향이 있으므)
   하고 이것을 중심으로 다른 엔티티를 나열하면서 전개함. 해당 업무에서 가장 중요한 엔티티는 왼쪽 상단에서 조금 아래쪽 중앙으로 배치해야 관련 엔티티와 관계선을 연결할 때 효과적으로 배치할 수 있다. 
  
  
* 엔터티의 특징 
1) 반드시 해당업무에서 필요하고 관리하고자 하는 정보여야한다. 
2) 유일한 식별자에 의해 식별이 가능해야한다.
3) 영속적으로 존재하는 인스턴스의 집합이어야한다. 
4) 엔터티는 업무프로세스에 의해 이용되어야한다. 
5) 엔터티는 반드시 속성이 있어야한다. 
6) 엔터티는 다른 엔터티와 최소 한개이상의 관계가 있어야한다. 

* 키엔터티  (기본엔터티)
업무에 원래 존재하는 정보, 다른 엔터티와의 관계에 의해 생성되지 않고 독립적으로 생성이 가능하고, 자신은 타 엔터티의
부모역할을 하게 된다. 다른 엔터티로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가지게 된다. 

* 속성 
속성이란 업무에서 필요로 하는 인스턴스에서 관리하고자 하는 의미상 더이상 분리되지 않는 최소의 데이터 단위이다. 

1. 원금, 예치기간은 기본 속성
2. 이자율은 기본 속성, 이자는 파생속성이다. (파생속성은 데이터를 조회할 때 빠른 성능을 낼 수 있도록 원래 속성의 값을 계산하여 저장할 수 있도록 만든 속성이다. )
3. 예금 분류는 설계 속성 


* 도메인 
각 엔터티(테이블)의 속성에 대해서 어떤 유형의 값이 들어가는지를 정의하는 개념은 도메인에 해당한다. 
주문이라는 엔터티가 있을 때 단가라는 속성값의 범위는 100에서 10000사이의 문자열.. 등 속성값에 대한 제약사항을 정의함 

* 속성의 명칭은 애매모호하지 않게 복합명사를 사용하여 구체적으로 명명함으로써 
전체 데이터모델에서 유일성을 확보하는 것이 반정규화 통합 등의 작업을 할 때 혼란을 방지할 수 있는 방법이 된다. 

엔터티간의 관계. 관계의 기수성을 나타내는 것은 관계 차수 개념과 관련있음. 1:1, 1:N 

* 엔터티 사이에 정의한 관계 체크 사항 
1. 두개의 엔터티 사이에 관심있는 연관규칙이 존재하는가?
2. 두개의 엔터티 사이에 정보의 조합이 발생하는가?
3. 업무 기술서, 장표에 관계 연결을 가능하게 하는 동사가 있는가?
4. 업무 기술서, 장표에 관계 연결에 대한 규칙이 서술되어있는가?

* 주식별자를 지정할 때 고려해야할 사항 
1. 주식별자에 의해 엔터티 내의 모든 인스턴스들이 유일하게 구분되어야 한다. 
2. 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야한다. 
3. 지정된 주 식별자의 값은 자주 변하지 않는 것이어야한다. 
4. 주 식별자가 지정이 되면 반드시 값이 들어와야 한다. 


2021.08.29 

* 파티셔닝 
하나의 테이블에 많은 양의 데이터가 저장되면 인덱스를 추가하고 테이블을 몇개로 쪼개도 성능이 저하되는 경우가 있다. 
이때 논리적으로는 하나의 테이블이지만, 물리적으로는 여러개의 테이블로 분리하여 데이터 엑세스 성능도 향상시키고, 
데이터 관리 방법도 개선할 수 있도록 테이블에 적용하는 기법이다. 
  
* 인덱스는 값의 범위에 따라 일정하게 정렬이 되므로 상수값으로 equal 조건으로 조회되는 컬럼이 가장 
앞으로 나오고 범위 조회하는유형의 컬럼이 그 다음에 나오도록 하는 것이 엑세스 범위를 좁힐 수 있다. 
* sql의 이콜 조건으로 나오는 컬럼을 테이블의 맨 처음 위치로 옮겨놓으면 인덱스이용 효율성이 높아진다. 
* 부모테이블의 fk 컬럼을 인덱스로 지정하여 부모테이블과의 조인시 성능저하를 예방한다. 

* 데이터베이스 분산 설계 
- 공통코드, 기준정보 등 마스터 데이터는 분산데이터베이스에 복제 분산을 적용한다. 
- 거의 실시간 (near real time)업무적인 특성을 가지고 있을 때는 분산 데이터 베이스를 사용하여 구성할 수 있다. 
- 백업 사이트를 구성할 때 간단하게 분산 기능을 적용하여 구성할 수 있다. 

* 데이터 제어어 (DCL: data control language) 는 데이터베이스에 접근하고 객체들을 사용할 수 있도록 
권한을 부여하거나 회수하는 명령어로 Grant, Revoke가 있다. 

* DCL 또는 TCL(transaction control language) 논리적인 작업의 단위를 묶어 DML에 의해 
조작된 결과를 작업단위 (Transaction) 별로 제어하는 명령어인 commit, rollback, savepoint 등이 있다. 

* DDL (data definition language) : 테이블의 구조를 생성, 변경, 삭제 하는 등 데이터 구조를 정의하는데 사용되는 명령어이다. 
스키마, 도메인, 테이블, 뷰, 인덱스를 정의하거나 변경 제거할때 사용한다. 
create, alter, drop, rename 

* DML : 데이터베이스 사용자가 응용 프로그램이나 질의어를 통하여 저장된 데이터베이스를 실질적으로 접근하는데 
사용되며 select, insert, delete, update등이 있다. 

* 비절차적 데이터 조작어(DML)은 사용자가 무슨 데이터를 원하는지만을 명세하지만, 절차적 데이터 조작어는 
어떻게 데이터를 접근해야하는지 명세한다. 절차적 데이터 조작어로는 PL/SQL(오라클), T-SQL(sql server) 등이 있다. 

* 테이블  primary key 컬럼 지정
alter table 테이블명 add constraint 키아이디 primary key (컬럼);

create table 테이블명 
(
	  컬럼정보 
	, 컬럼정보 
	, constraint 키아이디 primary key (컬럼)
); 

* 테이블 컬럼 정보 수정 
alter table 테이블명 modify (컬럼정보1, 컬럼정보2...);

* index 생성 
create index 인덱스아이디 on 테이블 (컬럼);

* null : 모르는 값, 값의 부재, null과의 모든 비교는 알 수 없음 (unknown)을 반환한다. 

* 테이블 생성시 컬럼에 default 값을 지정하더라도 not null 설정을 안하면 명시적으로 null 입력이 가능하다. 

* 테이블의 컬럼 삭제 
alter table 테이블명 drop column 컬럼명; 

* 자식 테이블 생성시 부모테이블 데이터 삭제될 때  자식 테이블의 행도 삭제하는 설정값 
on delete cascade 

* 테이블명 변경 
rename 테이블명 to 새로운테이블명; 

* 참조 동작 (Referential action )
- cascade: master 삭제시 child도 같이 삭제한다. 
- restrict: child 테이블에 pk 값이 없는 경우만 master 삭제 허용 
- automatic: master 테이블에 pk가 없는 경우 master pk생성후 child 입력 
- dependent: master 테이블에 pk 가 존재할 때 child 입력 허용 

* drop , truncate 는 auto commit 
* delete 는 사용자 commit 

* 데이터베이스 트랜젝션에 대한 격리성이 낮은 경우 발생할 수 있는 문제점 
- none-repeatable read: 한 트랜잭션 내에서 같은 쿼리를 두번 수행했는데, 그 사이에 다른 
트랜잭션이 값을 수정 또는 삭제하는 바람에 두 쿼리 결과가 다르게 나타나는 현상 
- phantom read: 한 트랜잭션 내에서 같은 쿼리를 두번 수행했는데, 첫번째 쿼리에서 없던 유령 레코드가 
두번째 쿼리에서 나타나는 현상 


* dirty read: 다른 트랜잭션에 의해 수정되었지만, 아직 커밋되지 않은 데이터를 읽는 것 
* isolation: 트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안된다. 

* oracle에서는 ddl문장 수행후 자동으로 commit을 수행하지만, sql server에서는 commit을 수행하지 않는다. 
* oracle에서는 ddl문장 수행후 auto commit을 수행하지만, sql server에서는 transaction의 범주에 포함하므로 rollback수행시 ddl 명령이 취소된다.

* 트랜잭션은 데이터베이스의 논리적 연산단위로서 밀접히 관련되어 분리될 수 없는 한개 이상의 데이터베이스 조작을 가리킨다. 

* 논리 연산자의 우선순위는 not > and > or 순이다. 

* null 허용 컬럼에 ''으로 값을 입력한 경우 oracle에서는 is null로 조회해야 값이 나오고, sql server에서는 = '' 로 조회해야 값이 나온다. 



* 2014년 11월 부터 2015년 3월까지 조회하는 쿼리 
select sum(xxx) 
from 테이블명 
where yyyy = '2014' and mm between '11' and '12'
or yyyy = '2015' and mm between '01' and '03'  -- 연산자의 우선순위 (and > or)에 의해 괄호가 없어도 된다. 


* to_date 조건 
'201501' = to_char(컬럼명, 'yyyymm') -- 2015년 1월 1일 전체 
to_date('201501', 'yyyymm') = 컬럼명 -- 2015년 1월 1일 00시 00분 00초인 데이터 

*  개행 문자 
select chr(10);

* oracle 날짜 계산 1/24/(60/10) = 10분 
select 
		to_char(to_date('2015.01.10 10', 'yyyy.mm.dd hh24') + 1/24/(60/10), 'yyyy.mm.dd hh24:mi:ss')
from dual;


* nullif(expr1, expr2)함수 : expr1과 expr2를 비교해서 같을 경우 null을 리턴하고 아니면 expr1을 리턴한다. 
* nvl(expr1, expr2)함수: expr1의 결과값이 null이면 표현식 2 의 값을 출력한다. 
* coalesce함수 null이 아닌 첫번째 값을 리턴함 
select coalesce(null, 0, 1);

* 여러개의 쿼리 실행 단축키 조합 : alt+x 

* null이 포함된 연산의 결과는 null
* 분모가 0인 연산은 에러가 발생함. 

* having절에는 select문에 없는 그룹함수구문을 사용할 수 있다. sql 실행순서에서 having절이 선행처리된다. 

* order by절에 case문을 사용할 수 있다. 
order by case when 컬럼 = 999 then 0 else 컬럼 end  => 컬럼값이 999이면 0으로 치환해서 asc 오름차순으로 정렬하여 999가 제일 첫행에 위치하게 한다. 

* select문장의 실행순서 
from - where - group by - having - select - order by 

* sql server에서 승리건수가 높은 순으로 3위를 출력하되 3위의 승리건수가 동일한 팀이 있다면 함께 출력하기 
select top(3) with ties 팀명, 승리건수 from 테이블 order by 승리건수 desc 

