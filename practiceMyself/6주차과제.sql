문제1번)  각 제품(product)의 제품명과 총 판매량( quantityordered )을 알려주세요. 추가로, 전체 판매량 또한 알려주세요. 


	답 SQL 은 여기 

SELECT P.PRODUCTNAME 
	 , SUM(OD.QUANTITYORDERED)
  FROM PRODUCTS P 
 INNER JOIN ORDER_DETAILS OD ON P.PRODUCTNUMBER = OD.PRODUCTNUMBER 
 GROUP BY ROLLUP (P.PRODUCTNAME)
 ORDER BY P.PRODUCTNAME 
	

문제2번)  주문 금액이 $1000 이상이며,  총 주문 횟수가 3회 이상인 고객 번호와 이름은? 


	답 SQL 은 여기 

SELECT C.CUSTOMERID 
     , C.CUSTFIRSTNAME || ' ' || C.CUSTLASTNAME AS CUSTOMERNAME
     , COUNT(DISTINCT O.ORDERNUMBER ) AS ORDER_COUNT
  FROM CUSTOMERS C 
 INNER JOIN ORDERS O ON O.CUSTOMERID = C.CUSTOMERID 
 INNER JOIN ORDER_DETAILS OD ON O.ORDERNUMBER = OD.ORDERNUMBER 
 WHERE ( OD.QUANTITYORDERED * OD.QUOTEDPRICE ) >= 1000 
GROUP BY C.CUSTOMERID, C.CUSTFIRSTNAME , C.CUSTLASTNAME 
HAVING COUNT(DISTINCT O.ORDERNUMBER ) >= 3
ORDER BY ORDER_COUNT	
 
 
문제3번) 미국 서해안에 있는 주 (custstate ) 에서 전체 주문 금액이 $1,000,000 가 넘는 주를 보여주세요.

Hint  1. 서해안 주  : custstate  =  'WA', 'OR', 'CA'


	답 SQL 은 여기 
	
SELECT C.CUSTSTATE 
	  , SUM(OD.QUANTITYORDERED  * OD.QUOTEDPRICE ) AS ORDER_AMOUNT
  FROM CUSTOMERS C 
 INNER JOIN ORDERS O ON C.CUSTOMERID = O.CUSTOMERID 
 INNER JOIN ORDER_DETAILS OD ON OD.ORDERNUMBER = O.ORDERNUMBER 
 WHERE C.CUSTSTATE IN ('WA', 'OR', 'CA')
GROUP BY C.CUSTSTATE 
HAVING SUM(OD.QUANTITYORDERED  * OD.QUOTEDPRICE ) >= 1000000
	
	
	


문제4번)  헬멧을 주문한 적 없는 고객을 보여주세요. not exists를 꼭 활용하여 풀이해주세요.
Hint 1. Productname을 활용하여 헬맷 확인 (카테고리테이블 활용 X)


	답 SQL 은 여기 
	
SELECT C.* 
  FROM CUSTOMERS C
 WHERE NOT EXISTS (SELECT 1 
 					 FROM CUSTOMERS C2 
 					 INNER JOIN ORDERS O2 ON C2.CUSTOMERID = O2.CUSTOMERID 
 					 INNER JOIN ORDER_DETAILS OD2 ON O2.ORDERNUMBER = OD2.ORDERNUMBER 
 					 INNER JOIN PRODUCTS P2 ON OD2.PRODUCTNUMBER = P2.PRODUCTNUMBER 
 					 	                   AND PRODUCTNAME LIKE '%Helmet'
 					 WHERE C.CUSTOMERID = C2.CUSTOMERID 	                   
                   )
 
 					 
 					 
문제5번) 고객의 월별 주문 횟수가 3 번 이상을 기록한 적 있는 모든 고객 이름은 무엇인가요? (GROUP BY, HAVING, JOIN 사용)


	답 SQL 은 여기 
	
	
SELECT DISTINCT CUSTOMER_NAME
FROM (
		SELECT  
			   C.CUSTOMERID
			 , C.CUSTFIRSTNAME || ' ' || C.CUSTLASTNAME AS CUSTOMER_NAME
		     , TO_CHAR(O.ORDERDATE, 'YYYYMM') MM
		     , COUNT(DISTINCT O.ORDERNUMBER) AS ORDER_COUNT
		  FROM CUSTOMERS C
		 INNER JOIN ORDERS O ON C.CUSTOMERID = O.CUSTOMERID 
		 INNER JOIN ORDER_DETAILS OD ON OD.ORDERNUMBER = O.ORDERNUMBER   
		 GROUP BY C.CUSTOMERID, TO_CHAR(O.ORDERDATE, 'YYYYMM')	
		 HAVING COUNT(DISTINCT O.ORDERNUMBER) > 3
	) A 
order by CUSTOMER_NAME


문제6번)직원과 고객중이  이름이 동일한 사람이 있을까요?  있다면 해당 사람의 이름에 대해서 (이름+ 성) 형식으로 알려주세요.


	답 SQL 은 여기 
	
SELECT C.CUSTFIRSTNAME || ' ' || C.CUSTLASTNAME 
  FROM CUSTOMERS C
 INNER JOIN EMPLOYEES E 
  		  ON C.CUSTFIRSTNAME || ' ' || C.CUSTLASTNAME = E.EMPFIRSTNAME || ' ' || E.EMPLASTNAME 
 
  
	
	

문제7번)  2017년 09 월에 해당 하는 주문에 대해서, 1~10일, 11~20일, 21~30일에 대한 각각의 구간에 대한 주문 금액을 보여주세요. 
row 수는 1개로  1~10일에 해당하는 주문금액,  11~20일에 해당하는 주문금액, 21~30일에 해당하는 주문금액과 , 총 주문금액에 대한 컬럼으로 보여주세요.


	답 SQL 은 여기 

SELECT SUM( 
			CASE WHEN O.ORDERDATE BETWEEN '2017-09-01' AND '2017-09-10'
			     THEN OD.QUANTITYORDERED * OD.QUOTEDPRICE
		     	ELSE 0	
	     	END
		) AS ORDER_AMOUNT_1_10
		, SUM( 
			CASE WHEN O.ORDERDATE BETWEEN '2017-09-11' AND '2017-09-20'
			     THEN OD.QUANTITYORDERED * OD.QUOTEDPRICE
			     ELSE 0
	     	END
		) AS ORDER_AMOUNT_11_20
		, SUM( 
			CASE WHEN O.ORDERDATE BETWEEN '2017-09-21' AND '2017-09-30'
			     THEN OD.QUANTITYORDERED * OD.QUOTEDPRICE
			     ELSE 0
		     END
		) AS ORDER_AMOUNT_21_30
		, SUM( OD.QUANTITYORDERED * OD.QUOTEDPRICE ) AS TOTAL_ORDER_AMOUNT
  FROM ORDERS O 
 INNER JOIN ORDER_DETAILS OD ON O.ORDERNUMBER = OD.ORDERNUMBER 
 WHERE O.ORDERDATE BETWEEN '2017-09-01' AND '2017-09-30'
	


문제8번) 주문을 많이 한 고객 순서 대로 순위를 매겨 나열하세요.  (analytic function 활용)
- 같은 주문 수치 일 때, 같은 등수로 보여주세요.
- 순위는 1,2,3등의 형식으로 순차적인 값이 노출되어야 합니다.

- 단 고객의 리스트는 다음에 제한 조건을 가집니다.
- 월별 주문 5회 이상한 Case를  3개월 이상한 경험한 고객으로만 제한합니다. (3개월은 연속이던 불연속이던 상관없습니다.)
ex)  고객1이 1월에 6회 , 3월에 5회,  9월에 5회 주문한 경험이있다면 포함해야합니다. 


	답 SQL 은 여기 


SELECT 
	   C.CUSTOMERID 
	 , COUNT( DISTINCT O.ORDERNUMBER ) AS TOTAL_ORDER_COUNT
	 , DENSE_RANK() OVER(ORDER BY COUNT( DISTINCT O.ORDERNUMBER ) DESC ) AS RANK_NUMBER 
  FROM CUSTOMERS C 
 INNER JOIN ORDERS O ON C.CUSTOMERID = O.CUSTOMERID 
 INNER JOIN ORDER_DETAILS OD ON OD.ORDERNUMBER = O.ORDERNUMBER   
 WHERE C.CUSTOMERID IN (
		 		 SELECT DISTINCT CUSTOMERID
			 	   FROM (
							SELECT C.CUSTOMERID 
								 , TO_CHAR(O.ORDERDATE, 'YYYYMM') AS MM
								 , COUNT( DISTINCT O.ORDERNUMBER ) AS TOTAL_ORDER_COUNT
								 , COUNT( * ) OVER(PARTITION BY C.CUSTOMERID) AS CUSTOMER_MM_COUNT
							  FROM CUSTOMERS C 
							 INNER JOIN ORDERS O ON C.CUSTOMERID = O.CUSTOMERID 
							 INNER JOIN ORDER_DETAILS OD ON OD.ORDERNUMBER = O.ORDERNUMBER   
							 GROUP BY C.CUSTOMERID, TO_CHAR(O.ORDERDATE, 'YYYYMM')		 
							 HAVING COUNT( DISTINCT O.ORDERNUMBER ) >= 5
						) A 
					WHERE CUSTOMER_MM_COUNT >= 3
		 		)
 GROUP BY C.CUSTOMERID
 ORDER BY TOTAL_ORDER_COUNT DESC
 

문제9번) Tire 카테고리 주문 량이 매달 증가하고 있나요?  (2017년 1월 ~ 12월 까지 판매량만 확인하시면 됩니다.)
    월별 주문량을 이전 달 주문량과 함께 표기해 증가 여부를 알려주세요.  (analytic function 활용)
    -- 아래의 표기 값으로 산출 해주세요. 
    - 이전 달 보다 값이 크다면 ? 'PLUS'
    - 이전 달의 값이 현재 값 보다 크다면 ? 'MINUS'
    - 현재 달의 판매 량과 이전 달 값이 같다면 ? 'SAME'
    - 이 외의 Case 는 ? NULL 
    
 Hint 1. 카테고리 테이블 활용 필요  - "Tires" 카테고리 확인 
 

	답 SQL 은 여기 
	
WITH TEMP AS (
	SELECT TO_CHAR(O.ORDERDATE, 'YYYYMM') MM
		  , COUNT(DISTINCT O.ORDERNUMBER ) AS ORDER_COUNT
		  , LAG(COUNT(DISTINCT O.ORDERNUMBER), 1) OVER (ORDER BY TO_CHAR(O.ORDERDATE, 'YYYYMM') ) PRE_ORDER_COUNT
	  FROM ORDERS O 	  
	 INNER JOIN ORDER_DETAILS OD ON O.ORDERNUMBER = OD.ORDERNUMBER 
	 INNER JOIN PRODUCTS P2 ON OD.PRODUCTNUMBER = P2.PRODUCTNUMBER 
	 INNER JOIN CATEGORIES C ON P2.CATEGORYID = C.CATEGORYID 
	                        AND C.CATEGORYID = 6
	 WHERE O.ORDERDATE BETWEEN '2017-01-01' AND '2017-12-31'
	 GROUP BY TO_CHAR(O.ORDERDATE, 'YYYYMM')     
	ORDER BY MM
 ) 
 SELECT MM
 	  , PRE_ORDER_COUNT
 	  , ORDER_COUNT AS CURRENT_ORDER_COUNT
 	  , CASE WHEN PRE_ORDER_COUNT < ORDER_COUNT THEN 'PLUS'
 			 WHEN PRE_ORDER_COUNT > ORDER_COUNT THEN 'MINUS'
 			 WHEN PRE_ORDER_COUNT = ORDER_COUNT THEN 'SAME'
 			 ELSE ''
 	    END AS COMPARE_PRE_VALUE		 
  FROM TEMP
 
 

문제10번) 주문일자별,  직원이 처리한  주문 수를 알려주세요. 총 전체 주문 수도 함께 보여주세요.  


	답 SQL 은 여기 
	
	
SELECT O.ORDERDATE
	 , O.EMPLOYEEID
	 , COUNT(DISTINCT ORDERNUMBER) AS ORDER_COUNT
  FROM ORDERS O 
 GROUP BY GROUPING SETS ((O.ORDERDATE, O.EMPLOYEEID), ())
 ORDER BY O.ORDERDATE, O.EMPLOYEEID 
  